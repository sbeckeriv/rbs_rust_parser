captial_case = _{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")* }
string_literal = _{ "\"" ~ ASCII_ALPHANUMERIC* ~ "\"" | "'" ~ ASCII_ALPHANUMERIC* ~ "'" }
symbol_literal = _{ ":" ~ ASCII_ALPHANUMERIC+ }
w = _{ WHITE_SPACE+ }
wo = _{ WHITE_SPACE* }
integer_literal= _{ ASCII_DIGIT+ }
lower_case = _{ ASCII_ALPHA_LOWER{1} ~ (ASCII_ALPHANUMERIC | "_")* }
namespace = { "::"? ~ captial_case ~ "::"*  | "::" }

class_name = { namespace* ~ captial_case? }
interface_name = { namespace? ~ "_" ~ captial_case }
alias_name = { namespace? ~ lower_case }

type_variable = { captial_case }
type_arguments = { "["~wo ~ (ruby_type ~","? ~  wo )+ ~wo~ "]" }
literal = { string_literal | symbol_literal | integer_literal | "true" | "false" }
record_name = { lower_case }

ruby_type = {
  "^(" ~parameters~ ")" ~ w ~"->"~ wo ~ ruby_type
    | "self"
    | "instance"
    | "class"
    | "bool"
    | "untyped"
    | "nil"
    | "top"
    | "bot"
    | "void"
    | class_name ~ type_arguments
    | interface_name ~ type_arguments
    | "singleton(" ~ class_name ~ ")"
    //    | alias_name // why is this hear?
    | literal
    | "{"~wo ~ (record_name ~ ":"~wo ~ ruby_type ~ wo ~","?~wo)+ ~ wo~"}"
    | "["~wo~"]" | "[" ~ wo ~ ( ruby_type ~ ","? ~  wo  )+ ~ wo~"]"
    | type_variable
}
ruby_types = {
  (ruby_type ~ wo ~ "|" ~ wo)+ ~ wo ~ ruby_type
    | (ruby_type ~ wo ~ "&" ~ wo)+ ~ ruby_type
    | ruby_type ~ "?"
    | ruby_type
}

//method types
var_name = { lower_case }
parameter_prime = { "?"?~ "*"? ~(ruby_types ~ w ~ var_name | ruby_types) }
parameter = {
  "?"?~
    (
     "(" ~parameter_prime ~")"
     | parameter_prime
    )
}

required_positionals = { (parameter ~  wo ~ "," ~ wo)* ~wo ~ parameter}
keyword = { lower_case }
keywords =  {
  (
   ( keyword ~":" ~ w ~ parameter             // Required keyword
     | "?"~ keyword ~":" ~ w  ~ parameter )
   ~ ","?
  )*   // Optional keyword
    ~
    ("**" ~ parameter)*// Rest keyword
}

parameters = {
  wo~(
      ((parameter | keywords) ~  wo ~ "," ~ wo)+ ~wo~ (parameter | keywords)
      |   required_positionals
      | keywords
     )~wo ~ keywords ~wo

}


// members

ivar_member = { ivar_name ~ ":" ~ ruby_type }
ivar_name =  { "@" ~ lower_case }
method_name = {
  "[]"
    |"*"
    | "+"
    | "-"
    | "/"
    | "&"
    | "|"
    | "<<"
    | "^"
    |
    (
     (ASCII_ALPHA | "_" ) ~
     (ASCII_ALPHANUMERIC | "_" )* ~ ("!" | "?")? 
    )
}

arrow_type = {
 w ~ "->" ~  w  ~ ( "("~wo~ruby_types~wo~")" | ruby_type)
}
method_type = {
  "(" ~ wo ~ ")" ~ arrow_type
    |"(" ~ parameters ~ ")" ~ arrow_type 
    | "(" ~ parameters ~ ") { (" ~ parameters ~ ")" ~ w ~ "->"~  w ~"("~wo~ ruby_types~ wo ~")" ~ wo ~ "}" ~ arrow_type
    | "(" ~ parameters ~ ") ?{ (" ~ parameters ~ ")" ~ w ~ "->"~  w ~"("~wo  ~ ruby_type ~ wo ~")" ~ wo ~  "}" ~ arrow_type
    | "(" ~ parameters ~ ") { (" ~ parameters ~ ")" ~ w ~ "->"~  w ~ ruby_type ~ wo ~ "}" ~ arrow_type
    | "(" ~ parameters ~ ") ?{ (" ~ parameters ~ ")" ~ w ~ "->"~  w ~ ruby_type ~ wo ~  "}" ~ arrow_type
}
method_types_prime =  {
  (type_parameters*~ wo ~ method_type ~ wo ~ "|" ~ wo)* ~type_parameters* ~ method_type ~"?"?
}

method_types =  {
  "super" 
    |  "(" ~ wo ~ method_types_prime ~ wo ~ ")" // this might be a lie..
    |  method_types_prime 
}


method_member = {
  "def"~  w   ~ method_name ~ ":"~ w   ~ method_types
    | "def" ~  w  ~ "self." ~ method_name ~ ":"~  w   ~ method_types
    | "def" ~  w  ~ "self?." ~ method_name ~ ":"~  w   ~ method_types
}

alias_member = {
  "alias" ~w ~ method_name~w ~ method_name
    | "alias" ~ w ~"self." ~ method_name ~w~ "self." ~ method_name
}

attribute_type = { "attr_reader" | "attr_writer" | "attr_accessor" }

include_member = {
  "include"~ w ~ class_name ~ type_arguments
    | "include"~ w ~ interface_name ~ type_arguments
}
extend_member = {
  "extend"~ w ~ class_name ~ type_arguments
    | "extend"~ w ~ interface_name ~ type_arguments
}
prepend_member = {
  "prepend"~ w ~ class_name ~ type_arguments
}

type_parameters ={
  wo~"["~ wo  ~ (type_variable~ wo  ~ "," ~ wo )* ~ type_variable ~ wo  ~  "]" ~wo
}

attribute_member = {
  attribute_type ~  w  ~ method_name ~ ":"~  w  ~ ruby_type
    | attribute_type ~  w  ~ method_name ~ "("~  wo  ~ ivar_name~  wo  ~  ") :" ~  w ~ ruby_type
    | attribute_type ~  w  ~ method_name ~ "() :"~  w  ~ ruby_type
}

member = {
  comments* ~
    wo  ~
    (ivar_member
     | method_member
     | attribute_member
     | include_member
     | extend_member
     | prepend_member
     | alias_member
     | const_decl
     | class_decl
     | module_decl
     | "public"
     | "private"
    )
}

variance ={
  ("out" | "in") ~ w
}

module_type_parameter = {
  variance?  ~ type_variable
}

module_type_parameters ={
  "[" ~ (module_type_parameter ~ "," ~ wo )* ~ module_type_parameter ~"]"
}

const_name = {
  namespace? ~(ASCII_ALPHA | "_")+
}

global_name = { "$" ~ASCII_ALPHA }

global_decl = { global_name~ ":" ~w~ ruby_type }

extension_decl = {
  "extension" ~ class_name ~ type_parameters ~ "(" ~ captial_case ~ ")" ~ member+ ~ "end"
}

type_alias_decl = {
  "type" ~ alias_name ~ "=" ~ ruby_type
}

const_decl = {
  const_name ~ ":" ~ w ~ ruby_type
}

decl = {
  comments* ~
    (class_decl
     | module_decl
     | interface_decl
     | extension_decl
     | type_alias_decl
     | const_decl
     | global_decl
    )
}

class_decl = {
  "class" ~  w  ~ class_name ~ module_type_parameters* ~ NEWLINE+ ~ (member ~ NEWLINE* )* ~ NEWLINE* ~wo~ "end"
    | "class"~  w   ~ class_name ~ module_type_parameters*~  w   ~ "<"~  w   ~ class_name ~ type_arguments? ~ NEWLINE+ ~ (member ~ NEWLINE* )* ~ NEWLINE* ~ wo~ "end"
}
module_name = {
  captial_case
}

module_decl ={
  "module" ~ w ~ module_name ~ module_type_parameters* ~ NEWLINE+ ~ (member ~ NEWLINE*)* ~ NEWLINE*~wo ~ "end"
    | "module" ~ w ~ module_name ~ module_type_parameters ~ wo ~":" ~ wo ~ module_self_types ~NEWLINE+ ~ (member ~ NEWLINE* )* ~ NEWLINE* ~wo~ "end"
}

module_self_types ={
  class_name ~ type_arguments ~ "," ~ module_self_types
    | interface_name ~ type_arguments ~ "," ~ module_self_types
}

interface_decl ={
  "interface" ~ interface_name ~ module_type_parameters ~ interface_members ~ "end"
}

interface_members = {
  method_member
    | include_member
    | alias_member
}

no_newline = _{ SPACE_SEPARATOR  | MARK | SYMBOL | PUNCTUATION | NUMBER | LETTER }
comment = { wo ~ "#" ~ no_newline*  }
comments = { (comment ~ NEWLINE)+}
